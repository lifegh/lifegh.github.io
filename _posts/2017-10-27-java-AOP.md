---
layout: post
title: JavaSE-AOP(Hook)实现机制(JDK/cglib动态代理/ASM/Javassist/AspectJ)
tags: JavaSE
---
<html><head>
<link href="http://www.iteye.com/javascripts/syntaxhighlighter/SyntaxHighlighter.css?1448702469" media="screen" rel="stylesheet" type="text/css" />
</head>
 <body>
<div class="postbody clearfix">
原文: http://www.iteye.com/topic/1116696
<p><br><strong>1 AOP各种的实现</strong></p>
<p><strong></strong></p>
<p>AOP就是面向切面编程，我们可以从几个层面来实现AOP。
AOP实现时有三种方式：生成子类字节码、生成代理类字节码、直接修改原类的字节码</p>
<p><strong></strong></p>
<p><img alt="" src="http://dl.iteye.com/upload/attachment/571833/77bd18fc-0e29-3e25-9447-9ccb9a25a9a8.jpg"></p>
<p>在编译器修改源代码，在运行期字节码加载前修改字节码或字节码加载后动态创建代理类的字节码，以下是各种实现机制的比较。&nbsp;</p>
<p>&nbsp;</p>
<table style="border-collapse: collapse; border: #000000 1px solid;" cellspacing="1" border="1" class="MsoTableGrid" cellpadding="0">
<tbody><tr>
<td style="padding-bottom: 0cm; padding-left: 5.4pt; width: 26.7pt; padding-right: 5.4pt; background: #00b0f0; padding-top: 0cm;" width="36">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><strong><span style="font-size: small;"><span>类别</span></span></strong></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; padding-left: 5.4pt; width: 70.85pt; padding-right: 5.4pt; background: #00b0f0; padding-top: 0cm;" width="94">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><strong><span style="font-size: small;"><span>机制</span></span></strong></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; padding-left: 5.4pt; width: 134.65pt; padding-right: 5.4pt; background: #00b0f0; padding-top: 0cm;" width="180">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><strong><span style="font-size: small;"><span>原理</span></span></strong></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; padding-left: 5.4pt; width: 70.9pt; padding-right: 5.4pt; background: #00b0f0; padding-top: 0cm;" width="95">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><strong><span style="font-size: small;"><span>优点</span></span></strong></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; padding-left: 5.4pt; width: 123pt; padding-right: 5.4pt; background: #00b0f0; padding-top: 0cm;" width="164">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><strong><span style="font-size: small;"><span>缺点</span></span></strong></p>
</td>
</tr>
<tr style="height: 51.3pt;">
<td style="padding-bottom: 0cm; padding-left: 5.4pt; width: 26.7pt; padding-right: 5.4pt; background: #ffc000; height: 51.3pt; border-top: #ece9d8 solid; padding-top: 0cm;" width="36">
<p style="margin: 0cm 5.65pt 0pt;" class="MsoNormal"><span><span style="font-size: small;">静态</span><span><span style="font-size: small;">AOP</span></span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.85pt; padding-right: 5.4pt; height: 51.3pt; border-top: #ece9d8; padding-top: 0cm;" width="94">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>静态织入</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 134.65pt; padding-right: 5.4pt; height: 51.3pt; border-top: #ece9d8; padding-top: 0cm;" width="180">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>在编译期，切面直接以字节码的形式编译到目标字节码文件中。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.9pt; padding-right: 5.4pt; height: 51.3pt; border-top: #ece9d8; padding-top: 0cm;" width="95">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>对系统无性能影响。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 123pt; padding-right: 5.4pt; height: 51.3pt; border-top: #ece9d8; padding-top: 0cm;" width="164">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>灵活性不够。</span></span></p>
</td>
</tr>
<tr style="height: 2cm;">
<td style="padding-bottom: 0cm; padding-left: 5.4pt; width: 26.7pt; padding-right: 5.4pt; background: #ffc000; height: 2cm; border-top: #ece9d8 solid; padding-top: 0cm;" width="36">
<p style="text-align: center; margin: 0cm 5.65pt 0pt;" class="MsoNormal"><span><span style="font-size: small;">动态</span><span><span style="font-size: small;">AOP</span></span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.85pt; padding-right: 5.4pt; height: 2cm; border-top: #ece9d8; padding-top: 0cm;" width="94">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>动态代理</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 134.65pt; padding-right: 5.4pt; height: 2cm; border-top: #ece9d8; padding-top: 0cm;" width="180">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>在运行期，目标类加载后，为接口动态生成代理类，将切面植入到代理类中。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.9pt; padding-right: 5.4pt; height: 2cm; border-top: #ece9d8; padding-top: 0cm;" width="95">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>相对于静态</span><span><span style="font-family: Calibri;">AOP</span></span><span>更加灵活。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 123pt; padding-right: 5.4pt; height: 2cm; border-top: #ece9d8; padding-top: 0cm;" width="164">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>切入的关注点需要实现接口。对系统有一点性能影响。</span></span></p>
</td>
</tr>
<tr>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.85pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="94">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>动态字节码生成</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 134.65pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="180">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>在运行期，目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.9pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="95">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>没有接口也可以织入。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 123pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="164">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>扩展类的实例方法为</span><span><span style="font-family: Calibri;">final</span></span><span>时，则无法进行织入。</span></span></p>
</td>
</tr>
<tr>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.85pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="94">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>自定义类加载器</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 134.65pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="180">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>在运行期，目标加载前，将切面逻辑加到目标字节码里。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.9pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="95">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>可以对绝大部分类进行织入。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 123pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="164">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>代码中如果使用了其他类加载器，则这些类将不会被织入。</span></span></p>
</td>
</tr>
<tr>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.85pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="94">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>字节码转换</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 134.65pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="180">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>在运行期，所有类加载器加载字节码前，前进行拦截。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 70.9pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="95">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span style="font-size: small;"><span>可以对所有类进行织入。</span></span></p>
</td>
<td style="border-left: #ece9d8; padding-bottom: 0cm; background-color: transparent; padding-left: 5.4pt; width: 123pt; padding-right: 5.4pt; border-top: #ece9d8; padding-top: 0cm;" width="164">
<p style="margin: 0cm 0cm 0pt;" class="MsoNormal"><span><span style="font-family: Calibri; font-size: small;">&nbsp;</span></span></p>
</td>
</tr>
</tbody></table>
<p><br><br><strong>2 AOP里的公民</strong></p>
<ul>
<li>Joinpoint：拦截点，如某个业务方法。</li>
<li>Pointcut：Joinpoint的表达式，表示拦截哪些方法。一个Pointcut对应多个Joinpoint。 </li>
<li>Advice:&nbsp; 要切入的逻辑。</li>
<li>Before Advice 在方法前切入。</li>
<li>After Advice 在方法后切入，抛出异常时也会切入。</li>
<li>After Returning Advice 在方法返回后切入，抛出异常则不会切入。</li>
<li>After Throwing Advice 在方法抛出异常时切入。</li>
<li>Around Advice 在方法执行前后切入，可以中断或忽略原有流程的执行。 </li>
<li>公民之间的关系 <br><img alt="" src="http://dl.iteye.com/upload/attachment/571835/84ffee2b-bb05-3d3f-8fc4-5b6c7851cea5.jpg"><br>织入器通过在切面中定义pointcut来搜索目标（被代理类）的JoinPoint(切入点)，然后把要切入的逻辑（Advice）织入到目标对象里，生成代理类。 <br>
</li>
</ul>
<p><strong>3 AOP的实现机制&nbsp;<br></strong>&nbsp; 本章节将详细介绍AOP有各种实现机制。 </p>
<p><br><strong>3.1 动态代理 <br></strong>&nbsp; Java在JDK1.3后引入的动态代理机制，使我们可以在运行期动态的创建代理类。使用动态代理实现AOP需要有四个角色：被代理的类，被代理类的接口，织入器，和InvocationHandler，而织入器使用接口反射机制生成一个代理类，然后在这个代理类中织入代码。被代理的类是AOP里所说的目标，InvocationHandler是切面，它包含了Advice和Pointcut。 <br><img alt="" src="http://dl.iteye.com/upload/attachment/571837/f9d3a3b2-605c-3d01-8488-970d254acb88.jpg"><br><br><strong>3.1.1 使用动态代理</strong> <br>&nbsp; 那如何使用动态代理来实现AOP。下面的例子演示在方法执行前织入一段记录日志的代码，其中Business是代理类，LogInvocationHandler是记录日志的切面，IBusiness, IBusiness2是代理类的接口，Proxy.newProxyInstance是织入器。 <br>清单一：动态代理的演示</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20static%20void%20main(String%5B%5D%20args)%20%7B%20%0A%20%20%20%20%2F%2F%E9%9C%80%E8%A6%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E8%A2%AB%E4%BB%A3%E7%90%86%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E9%83%BD%E5%BF%85%E9%A1%BB%E5%9C%A8%E8%BF%99%E9%87%8C%E5%AE%9A%E4%B9%89%20%0A%20%20%20%20Class%5B%5D%20proxyInterface%20%3D%20new%20Class%5B%5D%20%7B%20IBusiness.class%2C%20IBusiness2.class%20%7D%3B%20%0A%20%20%20%20%2F%2F%E6%9E%84%E5%BB%BAAOP%E7%9A%84Advice%EF%BC%8C%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81%E4%BC%A0%E5%85%A5%E4%B8%9A%E5%8A%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%20%0A%20%20%20%20LogInvocationHandler%20handler%20%3D%20new%20LogInvocationHandler(new%20Business())%3B%20%0A%20%20%20%20%2F%2F%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E5%99%A8%20%0A%20%20%20%20ClassLoader%20classLoader%20%3D%20DynamicProxyDemo.class.getClassLoader()%3B%20%0A%20%20%20%20%2F%2F%E7%BB%87%E5%85%A5%E5%99%A8%EF%BC%8C%E7%BB%87%E5%85%A5%E4%BB%A3%E7%A0%81%E5%B9%B6%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E7%B1%BB%20%0A%20%20%20%20IBusiness2%20proxyBusiness%20%3D%20(IBusiness2)%20Proxy.newProxyInstance(classLoader%2C%20proxyInterface%2C%20handler)%3B%20%0A%20%20%20%20%2F%2F%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%9D%A5%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%82%20%0A%20%20%20%20proxyBusiness.doSomeThing2()%3B%20%0A%20%20%20%20((IBusiness)%20proxyBusiness).doSomeThing()%3B%20%0A%7D%20%0A%0A%2F**%20%0A*%20%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E7%9A%84%E5%88%87%E9%9D%A2%20%0A*%2F%20%0Apublic%20static%20class%20LogInvocationHandler%20implements%20InvocationHandler%20%7B%20%0A%0A%20%20%20%20private%20Object%20target%3B%20%2F%2F%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%20%0A%0A%20%20%20%20LogInvocationHandler(Object%20target)%20%7B%20%0A%20%20%20%20%20%20%20%20this.target%20%3D%20target%3B%20%0A%20%20%20%20%7D%20%0A%0A%20%20%20%20%40Override%20%0A%20%20%20%20public%20Object%20invoke(Object%20proxy%2C%20Method%20method%2C%20Object%5B%5D%20args)%20throws%20Throwable%20%7B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E6%89%A7%E8%A1%8C%E5%8E%9F%E6%9C%89%E9%80%BB%E8%BE%91%20%0A%20%20%20%20%20%20%20%20Object%20rev%20%3D%20method.invoke(target%2C%20args)%3B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E6%89%A7%E8%A1%8C%E7%BB%87%E5%85%A5%E7%9A%84%E6%97%A5%E5%BF%97%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E6%8E%A7%E5%88%B6%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%88%87%E5%85%A5%E9%80%BB%E8%BE%91%20%0A%20%20%20%20%20%20%20%20if%20(method.getName().equals(%22doSomeThing2%22))%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20System.out.println(%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%22)%3B%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%20%20%20%20return%20rev%3B%20%0A%20%20%20%20%7D%20%0A%7D%20%0A%0A%E6%8E%A5%E5%8F%A3IBusiness%E5%92%8CIBusiness2%E5%AE%9A%E4%B9%89%E7%9C%81%E7%95%A5%E3%80%82%20%0A%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//需要代理的接口，被代理类实现的多个接口都必须在这里定义&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;Class[]&nbsp;proxyInterface&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Class[]&nbsp;{&nbsp;IBusiness.</span><span class="keyword">class</span><span>,&nbsp;IBusiness2.</span><span class="keyword">class</span><span>&nbsp;};&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//构建AOP的Advice，这里需要传入业务类的实例&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;LogInvocationHandler&nbsp;handler&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;LogInvocationHandler(</span><span class="keyword">new</span><span>&nbsp;Business());&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//生成代理类的字节码加载器&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;ClassLoader&nbsp;classLoader&nbsp;=&nbsp;DynamicProxyDemo.<span class="keyword">class</span><span>.getClassLoader();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//织入器，织入代码并生成代理类&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;IBusiness2&nbsp;proxyBusiness&nbsp;=&nbsp;(IBusiness2)&nbsp;Proxy.newProxyInstance(classLoader,&nbsp;proxyInterface,&nbsp;handler);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//使用代理类的实例来调用方法。&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;proxyBusiness.doSomeThing2();&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;((IBusiness)&nbsp;proxyBusiness).doSomeThing();&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="comment">/**&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">*&nbsp;打印日志的切面&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">*/</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;LogInvocationHandler&nbsp;</span><span class="keyword">implements</span><span>&nbsp;InvocationHandler&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span><span>&nbsp;Object&nbsp;target;&nbsp;</span><span class="comment">//目标对象&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;LogInvocationHandler(Object&nbsp;target)&nbsp;{&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span><span>.target&nbsp;=&nbsp;target;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;Object&nbsp;invoke(Object&nbsp;proxy,&nbsp;Method&nbsp;method,&nbsp;Object[]&nbsp;args)&nbsp;</span><span class="keyword">throws</span><span>&nbsp;Throwable&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//执行原有逻辑&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;rev&nbsp;=&nbsp;method.invoke(target,&nbsp;args);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//执行织入的日志，你可以控制哪些方法执行切入逻辑&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(method.getName().equals(</span><span class="string">"doSomeThing2"</span><span>))&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"记录日志"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;rev;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>接口IBusiness和IBusiness2定义省略。&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="0" title="AOP的实现机制" style="display: none;">public static void main(String[] args) { 
    //需要代理的接口，被代理类实现的多个接口都必须在这里定义 
    Class[] proxyInterface = new Class[] { IBusiness.class, IBusiness2.class }; 
    //构建AOP的Advice，这里需要传入业务类的实例 
    LogInvocationHandler handler = new LogInvocationHandler(new Business()); 
    //生成代理类的字节码加载器 
    ClassLoader classLoader = DynamicProxyDemo.class.getClassLoader(); 
    //织入器，织入代码并生成代理类 
    IBusiness2 proxyBusiness = (IBusiness2) Proxy.newProxyInstance(classLoader, proxyInterface, handler); 
    //使用代理类的实例来调用方法。 
    proxyBusiness.doSomeThing2(); 
    ((IBusiness) proxyBusiness).doSomeThing(); 
} 

//打印日志的切面 
public static class LogInvocationHandler implements InvocationHandler { 

    private Object target; //目标对象 

    LogInvocationHandler(Object target) { 
        this.target = target; 
    } 

    @Override 
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 
        //执行原有逻辑 
        Object rev = method.invoke(target, args); 
        //执行织入的日志，你可以控制哪些方法执行切入逻辑 
        if (method.getName().equals("doSomeThing2")) { 
            System.out.println("记录日志"); 
        } 
        return rev; 
    } 
} 

接口IBusiness和IBusiness2定义省略。 

</pre>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; 业务类，需要代理的类。</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20class%20Business%20implements%20IBusiness%2C%20IBusiness2%20%7B%20%0A%0A%20%20%20%20%40Override%20%0A%20%20%20%20public%20boolean%20doSomeThing()%20%7B%20%0A%20%20%20%20%20%20%20%20System.out.println(%22%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%22)%3B%20%0A%20%20%20%20%20%20%20%20return%20true%3B%20%0A%20%20%20%20%7D%20%0A%0A%20%20%20%20%40Override%20%0A%20%20%20%20public%20void%20doSomeThing2()%20%7B%20%0A%20%20%20%20%20%20%20%20System.out.println(%22%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%912%22)%3B%20%0A%20%20%20%20%7D%20%0A%0A%7D%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;Business&nbsp;</span><span class="keyword">implements</span><span>&nbsp;IBusiness,&nbsp;IBusiness2&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;doSomeThing()&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"执行业务逻辑"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">true</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;doSomeThing2()&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"执行业务逻辑2"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="1" title="AOP的实现机制" style="display: none;">public class Business implements IBusiness, IBusiness2 { 

    @Override 
    public boolean doSomeThing() { 
        System.out.println("执行业务逻辑"); 
        return true; 
    } 

    @Override 
    public void doSomeThing2() { 
        System.out.println("执行业务逻辑2"); 
    } 

} 
</pre>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; 输出</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%912%20%0A%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%20%0A%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span>执行业务逻辑</span><span class="number">2</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>记录日志&nbsp;&nbsp;&nbsp;</span></li><li><span>执行业务逻辑&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="2" title="AOP的实现机制" style="display: none;">执行业务逻辑2 
记录日志 
执行业务逻辑 
</pre>
<p>&nbsp;</p>
<p>&nbsp; 可以看到“记录日志”的逻辑切入到Business类的doSomeThing方法前了。 </p>
<p><br>&nbsp;</p>
<p><strong>3.1.2 动态代理原理</strong> <br>&nbsp;&nbsp;&nbsp; 本节将结合动态代理的源代码讲解其实现原理。动态代理的核心其实就是代理对象的生成，即Proxy.newProxyInstance(classLoader, proxyInterface, handler)。让我们进入newProxyInstance方法观摩下，核心代码其实就三行。 <br>清单二：生成代理类</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=%2F%2F%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E7%B1%BB%20%0AClass%20cl%20%3D%20getProxyClass(loader%2C%20interfaces)%3B%20%0A%2F%2F%E8%8E%B7%E5%8F%96%E5%B8%A6%E6%9C%89InvocationHandler%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%20%0AConstructor%20cons%20%3D%20cl.getConstructor(constructorParams)%3B%20%0A%2F%2F%E6%8A%8Ahandler%E4%BC%A0%E5%85%A5%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B%20%0Areturn%20(Object)%20cons.newInstance(new%20Object%5B%5D%20%7B%20h%20%7D)%3B%20%26nbsp%3B%20" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="comment">//获取代理类&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>Class&nbsp;cl&nbsp;=&nbsp;getProxyClass(loader,&nbsp;interfaces);&nbsp;&nbsp;&nbsp;</span></li><li><span><span class="comment">//获取带有InvocationHandler参数的构造方法&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>Constructor&nbsp;cons&nbsp;=&nbsp;cl.getConstructor(constructorParams);&nbsp;&nbsp;&nbsp;</span></li><li><span><span class="comment">//把handler传入构造方法生成实例&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">return</span><span>&nbsp;(Object)&nbsp;cons.newInstance(</span><span class="keyword">new</span><span>&nbsp;Object[]&nbsp;{&nbsp;h&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="3" title="AOP的实现机制" style="display: none;">//获取代理类 
Class cl = getProxyClass(loader, interfaces); 
//获取带有InvocationHandler参数的构造方法 
Constructor cons = cl.getConstructor(constructorParams); 
//把handler传入构造方法生成实例 
return (Object) cons.newInstance(new Object[] { h }); &nbsp; </pre>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 其中getProxyClass(loader, interfaces)方法用于获取代理类，它主要做了三件事情：在当前类加载器的缓存里搜索是否有代理类，没有则生成代理类并缓存在本地JVM里。清单三：查找代理类。</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=%26nbsp%3B%2F%2F%20%E7%BC%93%E5%AD%98%E7%9A%84key%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%90%8D%E7%A7%B0%E7%94%9F%E6%88%90%E7%9A%84List%20%0AObject%20key%20%3D%20Arrays.asList(interfaceNames)%3B%20%0Asynchronized%20(cache)%20%7B%20%0A%20%20%20%20do%20%7B%20%0AObject%20value%20%3D%20cache.get(key)%3B%20%0A%20%20%20%20%20%20%20%20%20%2F%2F%20%E7%BC%93%E5%AD%98%E9%87%8C%E4%BF%9D%E5%AD%98%E4%BA%86%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8%20%0Aif%20(value%20instanceof%20Reference)%20%7B%20%0A%20%20%20%20proxyClass%20%3D%20(Class)%20((Reference)%20value).get()%3B%20%0A%7D%20%0Aif%20(proxyClass%20!%3D%20null)%20%7B%20%0A%2F%2F%20%E4%BB%A3%E7%90%86%E7%B1%BB%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E5%88%99%E8%BF%94%E5%9B%9E%20%0A%20%20%20%20return%20proxyClass%3B%20%0A%7D%20else%20if%20(value%20%3D%3D%20pendingGenerationMarker)%20%7B%20%0A%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E4%BB%A3%E7%90%86%E7%B1%BB%E6%AD%A3%E5%9C%A8%E4%BA%A7%E7%94%9F%EF%BC%8C%E5%88%99%E7%AD%89%E5%BE%85%20%0A%20%20%20%20try%20%7B%20%0Acache.wait()%3B%20%0A%20%20%20%20%7D%20catch%20(InterruptedException%20e)%20%7B%20%0A%20%20%20%20%7D%20%0A%20%20%20%20continue%3B%20%0A%7D%20else%20%7B%20%0A%20%20%20%20%2F%2F%E6%B2%A1%E6%9C%89%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%8C%E5%88%99%E6%A0%87%E8%AE%B0%E4%BB%A3%E7%90%86%E5%87%86%E5%A4%87%E7%94%9F%E6%88%90%20%0A%20%20%20%20cache.put(key%2C%20pendingGenerationMarker)%3B%20%0A%20%20%20%20break%3B%20%0A%7D%20%0A%20%20%20%20%7D%20while%20(true)%3B%20%0A%7D%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span>&nbsp;</span><span class="comment">//&nbsp;缓存的key使用接口名称生成的List&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>Object&nbsp;key&nbsp;=&nbsp;Arrays.asList(interfaceNames);&nbsp;&nbsp;&nbsp;</span></li><li><span><span class="keyword">synchronized</span><span>&nbsp;(cache)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">do</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>Object&nbsp;value&nbsp;=&nbsp;cache.get(key);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;缓存里保存了代理类的引用&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">if</span><span>&nbsp;(value&nbsp;</span><span class="keyword">instanceof</span><span>&nbsp;Reference)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;proxyClass&nbsp;=&nbsp;(Class)&nbsp;((Reference)&nbsp;value).get();&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span><span class="keyword">if</span><span>&nbsp;(proxyClass&nbsp;!=&nbsp;</span><span class="keyword">null</span><span>)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="comment">//&nbsp;代理类已经存在则返回&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;proxyClass;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;<span class="keyword">else</span><span>&nbsp;</span><span class="keyword">if</span><span>&nbsp;(value&nbsp;==&nbsp;pendingGenerationMarker)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;如果代理类正在产生，则等待&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>cache.wait();&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(InterruptedException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">continue</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;<span class="keyword">else</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//没有代理类，则标记代理准备生成&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;cache.put(key,&nbsp;pendingGenerationMarker);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">break</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">while</span><span>&nbsp;(</span><span class="keyword">true</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="4" title="AOP的实现机制" style="display: none;">&nbsp;// 缓存的key使用接口名称生成的List 
Object key = Arrays.asList(interfaceNames); 
synchronized (cache) { 
    do { 
Object value = cache.get(key); 
         // 缓存里保存了代理类的引用 
if (value instanceof Reference) { 
    proxyClass = (Class) ((Reference) value).get(); 
} 
if (proxyClass != null) { 
// 代理类已经存在则返回 
    return proxyClass; 
} else if (value == pendingGenerationMarker) { 
    // 如果代理类正在产生，则等待 
    try { 
cache.wait(); 
    } catch (InterruptedException e) { 
    } 
    continue; 
} else { 
    //没有代理类，则标记代理准备生成 
    cache.put(key, pendingGenerationMarker); 
    break; 
} 
    } while (true); 
} 
</pre>
<p>&nbsp;&nbsp; </p>
<p>代理类的生成主要是以下这两行代码。 清单四：生成并加载代理类</p>
<p>&nbsp;</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=%2F%2F%E7%94%9F%E6%88%90%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A1%AC%E7%9B%98%E4%B8%AD(%E9%BB%98%E8%AE%A4%E4%B8%8D%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A1%AC%E7%9B%98)%20%0AproxyClassFile%20%3D%20ProxyGenerator.generateProxyClass(proxyName%2C%20interfaces)%3B%20%0A%2F%2F%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B0%86%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E4%B8%AD%20%0AproxyClass%20%3D%20defineClass0(loader%2C%20proxyName%2CproxyClassFile%2C%200%2C%20proxyClassFile.length)%3B%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="comment">//生成代理类的字节码文件并保存到硬盘中(默认不保存到硬盘)&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>proxyClassFile&nbsp;=&nbsp;ProxyGenerator.generateProxyClass(proxyName,&nbsp;interfaces);&nbsp;&nbsp;&nbsp;</span></li><li><span><span class="comment">//使用类加载器将字节码加载到内存中&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>proxyClass&nbsp;=&nbsp;defineClass0(loader,&nbsp;proxyName,proxyClassFile,&nbsp;<span class="number">0</span><span>,&nbsp;proxyClassFile.length);&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="5" title="AOP的实现机制" style="display: none;">//生成代理类的字节码文件并保存到硬盘中(默认不保存到硬盘) 
proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces); 
//使用类加载器将字节码加载到内存中 
proxyClass = defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length); 
</pre>
<p>&nbsp;</p>
<p>&nbsp; ProxyGenerator.generateProxyClass()方法属于sun.misc包下，Oracle并没有提供源代码，但是我们可以使用JD-GUI这样的反编译软件打开jre\lib\rt.jar来一探究竟，以下是其核心代码的分析。 <br>清单五：代理类的生成过程</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=%2F%2F%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%96%B9%E6%B3%95%E4%BD%93%E4%B8%BA%E7%A9%BA%20%0Afor%20(int%20i%20%3D%200%3B%20i%20%3C%20this.interfaces.length%3B%20i%2B%2B)%20%7B%20%0A%20%20localObject1%20%3D%20this.interfaces%5Bi%5D.getMethods()%3B%20%0A%20%20for%20(int%20k%20%3D%200%3B%20k%20%3C%20localObject1.length%3B%20k%2B%2B)%20%7B%20%0A%20%20%20%20%20addProxyMethod(localObject1%5Bk%5D%2C%20this.interfaces%5Bi%5D)%3B%20%0A%20%20%7D%20%0A%7D%20%0A%0A%2F%2F%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89InvocationHandler%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%20%0AMethodInfo%20localMethodInfo%20%3D%20new%20MethodInfo(%22%3Cinit%3E%22%2C%20%22(Ljava%2Flang%2Freflect%2FInvocationHandler%3B)V%22%2C%201)%3B%20%0A%0A%2F%2F%E5%BE%AA%E7%8E%AF%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95%E4%BD%93%E4%BB%A3%E7%A0%81%EF%BC%88%E7%9C%81%E7%95%A5%EF%BC%89%20%0A%2F%2F%E6%96%B9%E6%B3%95%E4%BD%93%E9%87%8C%E7%94%9F%E6%88%90%E8%B0%83%E7%94%A8InvocationHandler%E7%9A%84invoke%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E3%80%82%EF%BC%88%E6%AD%A4%E5%A4%84%E6%9C%89%E6%89%80%E7%9C%81%E7%95%A5%EF%BC%89%20%0Athis.cp.getInterfaceMethodRef(%22InvocationHandler%22%2C%20%22invoke%22%2C%20%22Object%3B%20Method%3B%20Object%3B%22)%20%0A%0A%2F%2F%E5%B0%86%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%8C%E5%86%99%E5%85%A5%E7%A1%AC%E7%9B%98%EF%BC%8C%E5%89%8D%E9%9D%A2%E6%9C%89%E4%B8%AAif%E5%88%A4%E6%96%AD%EF%BC%8C%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E4%BF%9D%E5%AD%98%E5%88%B0%E7%A1%AC%E7%9B%98%E3%80%82%20%0AlocalFileOutputStream%20%3D%20new%20FileOutputStream(ProxyGenerator.access%24000(this.val%24name)%20%2B%20%22.class%22)%3B%20%0AlocalFileOutputStream.write(this.val%24classFile)%3B%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="comment">//添加接口中定义的方法，此时方法体为空&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">for</span><span>&nbsp;(</span><span class="keyword">int</span><span>&nbsp;i&nbsp;=&nbsp;</span><span class="number">0</span><span>;&nbsp;i&nbsp;&lt;&nbsp;</span><span class="keyword">this</span><span>.interfaces.length;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;localObject1&nbsp;=&nbsp;<span class="keyword">this</span><span>.interfaces[i].getMethods();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;<span class="keyword">for</span><span>&nbsp;(</span><span class="keyword">int</span><span>&nbsp;k&nbsp;=&nbsp;</span><span class="number">0</span><span>;&nbsp;k&nbsp;&lt;&nbsp;localObject1.length;&nbsp;k++)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addProxyMethod(localObject1[k],&nbsp;<span class="keyword">this</span><span>.interfaces[i]);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="comment">//添加一个带有InvocationHandler的构造方法&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>MethodInfo&nbsp;localMethodInfo&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;MethodInfo(</span><span class="string">"&lt;init&gt;"</span><span>,&nbsp;</span><span class="string">"(Ljava/lang/reflect/InvocationHandler;)V"</span><span>,&nbsp;</span><span class="number">1</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="comment">//循环生成方法体代码（省略）&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="comment">//方法体里生成调用InvocationHandler的invoke方法代码。（此处有所省略）&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">this</span><span>.cp.getInterfaceMethodRef(</span><span class="string">"InvocationHandler"</span><span>,&nbsp;</span><span class="string">"invoke"</span><span>,&nbsp;</span><span class="string">"Object;&nbsp;Method;&nbsp;Object;"</span><span>)&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="comment">//将生成的字节码，写入硬盘，前面有个if判断，默认情况下不保存到硬盘。&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>localFileOutputStream&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;FileOutputStream(ProxyGenerator.access$</span><span class="number">000</span><span>(</span><span class="keyword">this</span><span>.val$name)&nbsp;+&nbsp;</span><span class="string">".class"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>localFileOutputStream.write(<span class="keyword">this</span><span>.val$classFile);&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="6" title="AOP的实现机制" style="display: none;">//添加接口中定义的方法，此时方法体为空 
for (int i = 0; i &lt; this.interfaces.length; i++) { 
  localObject1 = this.interfaces[i].getMethods(); 
  for (int k = 0; k &lt; localObject1.length; k++) { 
     addProxyMethod(localObject1[k], this.interfaces[i]); 
  } 
} 

//添加一个带有InvocationHandler的构造方法 
MethodInfo localMethodInfo = new MethodInfo("&lt;init&gt;", "(Ljava/lang/reflect/InvocationHandler;)V", 1); 

//循环生成方法体代码（省略） 
//方法体里生成调用InvocationHandler的invoke方法代码。（此处有所省略） 
this.cp.getInterfaceMethodRef("InvocationHandler", "invoke", "Object; Method; Object;") 

//将生成的字节码，写入硬盘，前面有个if判断，默认情况下不保存到硬盘。 
localFileOutputStream = new FileOutputStream(ProxyGenerator.access$000(this.val$name) + ".class"); 
localFileOutputStream.write(this.val$classFile); 
</pre>
<p>&nbsp;</p>
<p>&nbsp; 那么通过以上分析，我们可以推出动态代理为我们生成了一个这样的代理类。把方法doSomeThing的方法体修改为调用LogInvocationHandler的invoke方法。 <br>清单六：生成的代理类源码</p>
<p>&nbsp;</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20class%20ProxyBusiness%20implements%20IBusiness%2C%20IBusiness2%20%7B%20%0A%0Aprivate%20LogInvocationHandler%20h%3B%20%0A%0A%40Override%20%0Apublic%20void%20doSomeThing2()%20%7B%20%0A%20%20%20%20try%20%7B%20%0A%20%20%20%20%20%20%20%20Method%20m%20%3D%20(h.target).getClass().getMethod(%22doSomeThing%22%2C%20null)%3B%20%0A%20%20%20%20%20%20%20%20h.invoke(this%2C%20m%2C%20null)%3B%20%0A%20%20%20%20%7D%20catch%20(Throwable%20e)%20%7B%20%0A%20%20%20%20%20%20%20%20%2F%2F%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E7%95%A5%EF%BC%89%20%0A%20%20%20%20%7D%20%0A%7D%20%0A%0A%40Override%20%0Apublic%20boolean%20doSomeThing()%20%7B%20%0A%20%20%20%20try%20%7B%20%0A%20%20%20%20%20%20%20Method%20m%20%3D%20(h.target).getClass().getMethod(%22doSomeThing2%22%2C%20null)%3B%20%0A%20%20%20%20%20%20%20return%20(Boolean)%20h.invoke(this%2C%20m%2C%20null)%3B%20%0A%20%20%20%20%7D%20catch%20(Throwable%20e)%20%7B%20%0A%20%20%20%20%20%20%20%20%2F%2F%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88%E7%95%A5%EF%BC%89%20%0A%20%20%20%20%7D%20%0A%20%20%20%20return%20false%3B%20%0A%7D%20%0A%0Apublic%20ProxyBusiness(LogInvocationHandler%20h)%20%7B%20%0A%20%20%20%20this.h%20%3D%20h%3B%20%0A%7D%20%0A%0A%2F%2F%E6%B5%8B%E8%AF%95%E7%94%A8%20%0Apublic%20static%20void%20main(String%5B%5D%20args)%20%7B%20%0A%20%20%20%20%2F%2F%E6%9E%84%E5%BB%BAAOP%E7%9A%84Advice%20%0A%20%20%20%20LogInvocationHandler%20handler%20%3D%20new%20LogInvocationHandler(new%20Business())%3B%20%0A%20%20%20%20new%20ProxyBusiness(handler).doSomeThing()%3B%20%0A%20%20%20%20new%20ProxyBusiness(handler).doSomeThing2()%3B%20%0A%7D%20%0A%7D%20%0A%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;ProxyBusiness&nbsp;</span><span class="keyword">implements</span><span>&nbsp;IBusiness,&nbsp;IBusiness2&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="keyword">private</span><span>&nbsp;LogInvocationHandler&nbsp;h;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="annotation">@Override</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;doSomeThing2()&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;m&nbsp;=&nbsp;(h.target).getClass().getMethod(<span class="string">"doSomeThing"</span><span>,&nbsp;</span><span class="keyword">null</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h.invoke(<span class="keyword">this</span><span>,&nbsp;m,&nbsp;</span><span class="keyword">null</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(Throwable&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;异常处理（略）&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="annotation">@Override</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;doSomeThing()&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;m&nbsp;=&nbsp;(h.target).getClass().getMethod(<span class="string">"doSomeThing2"</span><span>,&nbsp;</span><span class="keyword">null</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;(Boolean)&nbsp;h.invoke(</span><span class="keyword">this</span><span>,&nbsp;m,&nbsp;</span><span class="keyword">null</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(Throwable&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;异常处理（略）&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">false</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="keyword">public</span><span>&nbsp;ProxyBusiness(LogInvocationHandler&nbsp;h)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span><span>.h&nbsp;=&nbsp;h;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="comment">//测试用&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//构建AOP的Advice&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;LogInvocationHandler&nbsp;handler&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;LogInvocationHandler(</span><span class="keyword">new</span><span>&nbsp;Business());&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span><span>&nbsp;ProxyBusiness(handler).doSomeThing();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span><span>&nbsp;ProxyBusiness(handler).doSomeThing2();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="7" title="AOP的实现机制" style="display: none;">public class ProxyBusiness implements IBusiness, IBusiness2 { 

private LogInvocationHandler h; 

@Override 
public void doSomeThing2() { 
    try { 
        Method m = (h.target).getClass().getMethod("doSomeThing", null); 
        h.invoke(this, m, null); 
    } catch (Throwable e) { 
        // 异常处理（略） 
    } 
} 

@Override 
public boolean doSomeThing() { 
    try { 
       Method m = (h.target).getClass().getMethod("doSomeThing2", null); 
       return (Boolean) h.invoke(this, m, null); 
    } catch (Throwable e) { 
        // 异常处理（略） 
    } 
    return false; 
} 

public ProxyBusiness(LogInvocationHandler h) { 
    this.h = h; 
} 

//测试用 
public static void main(String[] args) { 
    //构建AOP的Advice 
    LogInvocationHandler handler = new LogInvocationHandler(new Business()); 
    new ProxyBusiness(handler).doSomeThing(); 
    new ProxyBusiness(handler).doSomeThing2(); 
} 
} 

</pre>
<p>&nbsp;</p>
<p><strong>3.1.3 小结&nbsp;<br></strong>&nbsp;&nbsp;&nbsp; 从前两节的分析我们可以看出，动态代理在运行期通过接口动态生成代理类，这为其带来了一定的灵活性，但这个灵活性却带来了两个问题，第一代理类必须实现一个接口，如果没实现接口会抛出一个异常。第二性能影响，因为动态代理使用反射的机制实现的，首先反射肯定比直接调用要慢，经过测试大概每个代理类比静态代理多出10几毫秒的消耗。其次使用反射大量生成类文件可能引起Full GC造成性能影响，因为字节码文件加载后会存放在JVM运行时区的方法区（或者叫持久代）中，当方法区满的时候，会引起Full GC，所以当你大量使用动态代理时，可以将持久代设置大一些，减少Full GC次数。 <br><br><strong>3.2 动态字节码生成</strong> <br>&nbsp;&nbsp; 使用动态字节码生成技术实现AOP原理是在运行期间目标字节码加载后，生成目标类的子类，将切面逻辑加入到子类中，所以使用Cglib实现AOP不需要基于接口。</p>
<p><img alt="" src="http://dl.iteye.com/upload/attachment/571839/99ba1fdf-d985-38fd-abb0-6cab3c7878ab.jpg"></p>
<p><br>&nbsp;&nbsp;&nbsp; 本节介绍如何使用Cglib来实现动态字节码技术。Cglib是一个强大的,高性能的Code生成类库，它可以在运行期间扩展Java类和实现Java接口，它封装了Asm，所以使用Cglib前需要引入Asm的jar。 清单七：使用CGLib实现AOP</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20static%20void%20main(String%5B%5D%20args)%20%7B%20%0A%20%20%20%20%20%20%20%20byteCodeGe()%3B%20%0A%20%20%20%20%7D%20%0A%0A%20%20%20%20public%20static%20void%20byteCodeGe()%20%7B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%87%E5%85%A5%E5%99%A8%20%0A%20%20%20%20%20%20%20%20Enhancer%20enhancer%20%3D%20new%20Enhancer()%3B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AE%E7%88%B6%E7%B1%BB%20%0A%20%20%20%20%20%20%20%20enhancer.setSuperclass(Business.class)%3B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E8%AE%BE%E7%BD%AE%E9%9C%80%E8%A6%81%E7%BB%87%E5%85%A5%E7%9A%84%E9%80%BB%E8%BE%91%20%0A%20%20%20%20%20%20%20%20enhancer.setCallback(new%20LogIntercept())%3B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E4%BD%BF%E7%94%A8%E7%BB%87%E5%85%A5%E5%99%A8%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%20%0A%20%20%20%20%20%20%20%20IBusiness2%20newBusiness%20%3D%20(IBusiness2)%20enhancer.create()%3B%20%0A%20%20%20%20%20%20%20%20newBusiness.doSomeThing2()%3B%20%0A%20%20%20%20%7D%20%0A%0A%20%20%20%20%2F**%20%0A%20%20%20%20%20*%20%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%20%0A%20%20%20%20%20*%2F%20%0A%20%20%20%20public%20static%20class%20LogIntercept%20implements%20MethodInterceptor%20%7B%20%0A%0A%20%20%20%20%20%20%20%20%40Override%20%0A%20%20%20%20%20%20%20%20public%20Object%20intercept(Object%20target%2C%20Method%20method%2C%20Object%5B%5D%20args%2C%20MethodProxy%20proxy)%20throws%20Throwable%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%89%A7%E8%A1%8C%E5%8E%9F%E6%9C%89%E9%80%BB%E8%BE%91%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E6%98%AFinvokeSuper%20%0A%20%20%20%20%20%20%20%20%20%20%20%20Object%20rev%20%3D%20proxy.invokeSuper(target%2C%20args)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E6%89%A7%E8%A1%8C%E7%BB%87%E5%85%A5%E7%9A%84%E6%97%A5%E5%BF%97%20%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(method.getName().equals(%22doSomeThing2%22))%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20System.out.println(%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%22)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20rev%3B%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%7D%20%0A%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteCodeGe();&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;byteCodeGe()&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//创建一个织入器&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enhancer&nbsp;enhancer&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Enhancer();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//设置父类&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enhancer.setSuperclass(Business.<span class="keyword">class</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//设置需要织入的逻辑&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enhancer.setCallback(<span class="keyword">new</span><span>&nbsp;LogIntercept());&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//使用织入器创建子类&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IBusiness2&nbsp;newBusiness&nbsp;=&nbsp;(IBusiness2)&nbsp;enhancer.create();&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newBusiness.doSomeThing2();&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/**&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;记录日志&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;LogIntercept&nbsp;</span><span class="keyword">implements</span><span>&nbsp;MethodInterceptor&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;Object&nbsp;intercept(Object&nbsp;target,&nbsp;Method&nbsp;method,&nbsp;Object[]&nbsp;args,&nbsp;MethodProxy&nbsp;proxy)&nbsp;</span><span class="keyword">throws</span><span>&nbsp;Throwable&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//执行原有逻辑，注意这里是invokeSuper&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;rev&nbsp;=&nbsp;proxy.invokeSuper(target,&nbsp;args);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//执行织入的日志&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(method.getName().equals(</span><span class="string">"doSomeThing2"</span><span>))&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class="string">"记录日志"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;rev;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="8" title="AOP的实现机制" style="display: none;">public static void main(String[] args) { 
        byteCodeGe(); 
    }
public static void byteCodeGe() { 
	//创建一个织入器 
	Enhancer enhancer = new Enhancer(); 
	//设置父类 
	enhancer.setSuperclass(Business.class); 
	//设置需要织入的逻辑 
	enhancer.setCallback(new LogIntercept()); 
	//使用织入器创建子类 
	IBusiness2 newBusiness = (IBusiness2) enhancer.create(); 
	newBusiness.doSomeThing2(); 
} 

//记录日志  
public static class LogIntercept implements MethodInterceptor { 

	@Override 
	public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable { 
		//执行原有逻辑，注意这里是invokeSuper 
		Object rev = proxy.invokeSuper(target, args); 
		//执行织入的日志 
		if (method.getName().equals("doSomeThing2")) { 
			System.out.println("记录日志"); 
		} 
		return rev; 
	} 
}
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>3.3 自定义类加载器</strong> <br>&nbsp;&nbsp; 如果我们实现了一个自定义类加载器，在类加载到JVM之前直接修改某些类的方法，并将切入逻辑织入到这个方法里，然后将修改后的字节码文件交给虚拟机运行，那岂不是更直接。</p>
<p>&nbsp;</p>
<p><img alt="" src="http://dl.iteye.com/upload/attachment/571841/ef3e2a02-26b0-3912-badb-6cacb567a5c2.jpg"><br><br>Javassist是一个编辑字节码的框架，可以让你很简单地操作字节码。它可以在运行期定义或修改Class。使用Javassist实现AOP的原理是在字节码加载前直接修改需要切入的方法。这比使用Cglib实现AOP更加高效，并且没太多限制，实现原理如下图： <br><br><img alt="" src="http://dl.iteye.com/upload/attachment/571843/0b83bbac-1ebe-3346-845c-2a636145b0ed.jpg"><br><br><br><br><br>&nbsp;&nbsp;&nbsp; 我们使用系统类加载器启动我们自定义的类加载器，在这个类加载器里加一个类加载监听器，监听器发现目标类被加载时就织入切入逻辑，咱们再看看使用Javassist实现AOP的代码： <br>清单八：启动自定义的类加载器</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=%2F%2F%E8%8E%B7%E5%8F%96%E5%AD%98%E6%94%BECtClass%E7%9A%84%E5%AE%B9%E5%99%A8ClassPool%20%0AClassPool%20cp%20%3D%20ClassPool.getDefault()%3B%20%0A%2F%2F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%20%0ALoader%20cl%20%3D%20new%20Loader()%3B%20%0A%2F%2F%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%BD%AC%E6%8D%A2%E5%99%A8%20%0Acl.addTranslator(cp%2C%20new%20MyTranslator())%3B%20%0A%2F%2F%E5%90%AF%E5%8A%A8MyTranslator%E7%9A%84main%E5%87%BD%E6%95%B0%20%0Acl.run(%22jsvassist.JavassistAopDemo%24MyTranslator%22%2C%20args)%3B%20%0A%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="comment">//获取存放CtClass的容器ClassPool&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>ClassPool&nbsp;cp&nbsp;=&nbsp;ClassPool.getDefault();&nbsp;&nbsp;&nbsp;</span></li><li><span><span class="comment">//创建一个类加载器&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>Loader&nbsp;cl&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Loader();&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="comment">//增加一个转换器&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>cl.addTranslator(cp,&nbsp;<span class="keyword">new</span><span>&nbsp;MyTranslator());&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="comment">//启动MyTranslator的main函数&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>cl.run(<span class="string">"jsvassist.JavassistAopDemo$MyTranslator"</span><span>,&nbsp;args);&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="9" title="AOP的实现机制" style="display: none;">//获取存放CtClass的容器ClassPool 
ClassPool cp = ClassPool.getDefault(); 
//创建一个类加载器 
Loader cl = new Loader(); 
//增加一个转换器 
cl.addTranslator(cp, new MyTranslator()); 
//启动MyTranslator的main函数 
cl.run("jsvassist.JavassistAopDemo$MyTranslator", args); 

</pre>
<p>&nbsp;清单九：类加载监听器</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20static%20class%20MyTranslator%20implements%20Translator%20%7B%20%0A%0A%20%20%20%20%20%20%20%20public%20void%20start(ClassPool%20pool)%20throws%20NotFoundException%2C%20CannotCompileException%20%7B%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%0A%20%20%20%20%20%20%20%20%2F*%20*%20%0A%20%20%20%20%20%20%20%20%20*%20%E7%B1%BB%E8%A3%85%E8%BD%BD%E5%88%B0JVM%E5%89%8D%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%BB%87%E5%85%A5%20%0A%20%20%20%20%20%20%20%20%20*%2F%20%0A%20%20%20%20%20%20%20%20public%20void%20onLoad(ClassPool%20pool%2C%20String%20classname)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20(!%22model%24Business%22.equals(classname))%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E9%80%9A%E8%BF%87%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%96%87%E4%BB%B6%20%0A%20%20%20%20%20%20%20%20%20%20%20%20try%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20CtClass%20%20cc%20%3D%20pool.get(classname)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E8%8E%B7%E5%BE%97%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95%E5%90%8D%E7%9A%84%E6%96%B9%E6%B3%95%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20CtMethod%20m%20%3D%20cc.getDeclaredMethod(%22doSomeThing%22)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%9C%A8%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%89%8D%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20m.insertBefore(%22%7B%20System.out.println(%5C%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%5C%22)%3B%20%7D%22)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20catch%20(NotFoundException%20e)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20catch%20(CannotCompileException%20e)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%0A%20%20%20%20%20%20%20%20public%20static%20void%20main(String%5B%5D%20args)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20Business%20b%20%3D%20new%20Business()%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20b.doSomeThing2()%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20b.doSomeThing()%3B%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%7D%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;MyTranslator&nbsp;</span><span class="keyword">implements</span><span>&nbsp;Translator&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;start(ClassPool&nbsp;pool)&nbsp;</span><span class="keyword">throws</span><span>&nbsp;NotFoundException,&nbsp;CannotCompileException&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/*&nbsp;*&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;类装载到JVM前进行代码织入&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;onLoad(ClassPool&nbsp;pool,&nbsp;String&nbsp;classname)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!</span><span class="string">"model$Business"</span><span>.equals(classname))&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//通过获取类文件&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CtClass&nbsp;&nbsp;cc&nbsp;=&nbsp;pool.get(classname);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//获得指定方法名的方法&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CtMethod&nbsp;m&nbsp;=&nbsp;cc.getDeclaredMethod(<span class="string">"doSomeThing"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//在方法执行前插入代码&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.insertBefore(<span class="string">"{&nbsp;System.out.println(\"记录日志\");&nbsp;}"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(NotFoundException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(CannotCompileException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Business&nbsp;b&nbsp;=&nbsp;<span class="keyword">new</span><span>&nbsp;Business();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.doSomeThing2();&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.doSomeThing();&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="10" title="AOP的实现机制" style="display: none;">public static class MyTranslator implements Translator { 

        public void start(ClassPool pool) throws NotFoundException, CannotCompileException { 
        } 

        /* * 
         * 类装载到JVM前进行代码织入 
         */ 
        public void onLoad(ClassPool pool, String classname) { 
            if (!"model$Business".equals(classname)) { 
                return; 
            } 
            //通过获取类文件 
            try { 
                CtClass  cc = pool.get(classname); 
                //获得指定方法名的方法 
                CtMethod m = cc.getDeclaredMethod("doSomeThing"); 
                //在方法执行前插入代码 
                m.insertBefore("{ System.out.println(\"记录日志\"); }"); 
            } catch (NotFoundException e) { 
            } catch (CannotCompileException e) { 
            } 
        } 

        public static void main(String[] args) { 
            Business b = new Business(); 
            b.doSomeThing2(); 
            b.doSomeThing(); 
        } 
    } 
</pre>
<p>&nbsp;输出：&nbsp;</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%912%20%0A%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%20%0A%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span>执行业务逻辑</span><span class="number">2</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>记录日志&nbsp;&nbsp;&nbsp;</span></li><li><span>执行业务逻辑&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="11" title="AOP的实现机制" style="display: none;">执行业务逻辑2 
记录日志 
执行业务逻辑</pre>
<p>&nbsp; <br>&nbsp;&nbsp;&nbsp; 其中Bussiness类在本文的清单一中定义。看起来是不是特别简单，CtClass是一个class文件的抽象描述。咱们也可以使用insertAfter()在方法的末尾插入代码，使用insertAt()在指定行插入代码。 <br><br><strong>3.3.1 小结</strong> <br>&nbsp;&nbsp;&nbsp; 从本节中可知，使用自定义的类加载器实现AOP在性能上要优于动态代理和Cglib，因为它不会产生新类，但是它仍然存在一个问题，就是如果其他的类加载器来加载类的话，这些类将不会被拦截。 <br><br><strong>3.4 字节码转换</strong> <br>&nbsp;&nbsp;&nbsp; 自定义的类加载器实现AOP只能拦截自己加载的字节码，那么有没有一种方式能够监控所有类加载器加载字节码呢？有，使用Instrumentation，它是 Java 5 提供的新特性，使用 Instrumentation，开发者可以构建一个字节码转换器，在字节码加载前进行转换。本节使用Instrumentation和javassist来实现AOP。 <br><br><strong>3.4.1 构建字节码转换器</strong> <br>&nbsp;&nbsp;&nbsp; 首先需要创建字节码转换器，该转换器负责拦截Business类，并在Business类的doSomeThing方法前使用javassist加入记录日志的代码。</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20class%20MyClassFileTransformer%20implements%20ClassFileTransformer%20%7B%20%0A%0A%20%20%20%20%2F**%20%0A%20%20%20%20%20*%20%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A0%E8%BD%BD%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%89%8D%E4%BC%9A%E8%BF%9B%E5%85%A5%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%20%0A%20%20%20%20%20*%2F%20%0A%20%20%20%20%40Override%20%0A%20%20%20%20public%20byte%5B%5D%20transform(ClassLoader%20loader%2C%20String%20className%2C%20Class%3C%3F%3E%20classBeingRedefined%2C%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20ProtectionDomain%20protectionDomain%2C%20byte%5B%5D%20classfileBuffer)%20%0A%20%20%20%20%20%20%20%20%20%20%20%20throws%20IllegalClassFormatException%20%7B%20%0A%20%20%20%20%20%20%20%20System.out.println(className)%3B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E5%A6%82%E6%9E%9C%E5%8A%A0%E8%BD%BDBusiness%E7%B1%BB%E6%89%8D%E6%8B%A6%E6%88%AA%20%0A%20%20%20%20%20%20%20%20if%20(!%22model%2FBusiness%22.equals(className))%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20null%3B%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%0A%20%20%20%20%20%20%20%20%2F%2Fjavassist%E7%9A%84%E5%8C%85%E5%90%8D%E6%98%AF%E7%94%A8%E7%82%B9%E5%88%86%E5%89%B2%E7%9A%84%EF%BC%8C%E9%9C%80%E8%A6%81%E8%BD%AC%E6%8D%A2%E4%B8%8B%20%0A%20%20%20%20%20%20%20%20if%20(className.indexOf(%22%2F%22)%20!%3D%20-1)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20className%20%3D%20className.replaceAll(%22%2F%22%2C%20%22.%22)%3B%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%20%20%20%20try%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E9%80%9A%E8%BF%87%E5%8C%85%E5%90%8D%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%96%87%E4%BB%B6%20%0A%20%20%20%20%20%20%20%20%20%20%20%20CtClass%20cc%20%3D%20ClassPool.getDefault().get(className)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E8%8E%B7%E5%BE%97%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95%E5%90%8D%E7%9A%84%E6%96%B9%E6%B3%95%20%0A%20%20%20%20%20%20%20%20%20%20%20%20CtMethod%20m%20%3D%20cc.getDeclaredMethod(%22doSomeThing%22)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%9C%A8%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%89%8D%E6%8F%92%E5%85%A5%E4%BB%A3%E7%A0%81%20%0A%20%20%20%20%20%20%20%20%20%20%20%20m.insertBefore(%22%7B%20System.out.println(%5C%22%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%5C%22)%3B%20%7D%22)%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20cc.toBytecode()%3B%20%0A%20%20%20%20%20%20%20%20%7D%20catch%20(NotFoundException%20e)%20%7B%20%0A%20%20%20%20%20%20%20%20%7D%20catch%20(CannotCompileException%20e)%20%7B%20%0A%20%20%20%20%20%20%20%20%7D%20catch%20(IOException%20e)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%E5%BF%BD%E7%95%A5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%20%0A%20%20%20%20%20%20%20%20%7D%20%0A%20%20%20%20%20%20%20%20return%20null%3B%20%0A%7D%20%0A%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;MyClassFileTransformer&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ClassFileTransformer&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/**&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;字节码加载到虚拟机前会进入这个方法&nbsp;</span>&nbsp;</span></li><li><span><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="annotation">@Override</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">byte</span><span>[]&nbsp;transform(ClassLoader&nbsp;loader,&nbsp;String&nbsp;className,&nbsp;Class&lt;?&gt;&nbsp;classBeingRedefined,&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ProtectionDomain&nbsp;protectionDomain,&nbsp;<span class="keyword">byte</span><span>[]&nbsp;classfileBuffer)&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">throws</span><span>&nbsp;IllegalClassFormatException&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(className);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//如果加载Business类才拦截&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(!</span><span class="string">"model/Business"</span><span>.equals(className))&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">null</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//javassist的包名是用点分割的，需要转换下&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span><span>&nbsp;(className.indexOf(</span><span class="string">"/"</span><span>)&nbsp;!=&nbsp;-</span><span class="number">1</span><span>)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;className&nbsp;=&nbsp;className.replaceAll(<span class="string">"/"</span><span>,&nbsp;</span><span class="string">"."</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><span>&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//通过包名获取类文件&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CtClass&nbsp;cc&nbsp;=&nbsp;ClassPool.getDefault().get(className);&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//获得指定方法名的方法&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CtMethod&nbsp;m&nbsp;=&nbsp;cc.getDeclaredMethod(<span class="string">"doSomeThing"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//在方法执行前插入代码&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.insertBefore(<span class="string">"{&nbsp;System.out.println(\"记录日志\");&nbsp;}"</span><span>);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;cc.toBytecode();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(NotFoundException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(CannotCompileException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">catch</span><span>&nbsp;(IOException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//忽略异常处理&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;</span><span class="keyword">null</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="12" title="AOP的实现机制" style="display: none;">public class MyClassFileTransformer implements ClassFileTransformer {  
//字节码加载到虚拟机前会进入这个方法  
@Override 
public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, 
						ProtectionDomain protectionDomain, byte[] classfileBuffer) 
		throws IllegalClassFormatException { 
	System.out.println(className); 
	//如果加载Business类才拦截 
	if (!"model/Business".equals(className)) { 
		return null; 
	} 

	//javassist的包名是用点分割的，需要转换下 
	if (className.indexOf("/") != -1) { 
		className = className.replaceAll("/", "."); 
	} 
	try { 
		//通过包名获取类文件 
		CtClass cc = ClassPool.getDefault().get(className); 
		//获得指定方法名的方法 
		CtMethod m = cc.getDeclaredMethod("doSomeThing"); 
		//在方法执行前插入代码 
		m.insertBefore("{ System.out.println(\"记录日志\"); }"); 
		return cc.toBytecode(); 
	} catch (NotFoundException e) { 
	} catch (CannotCompileException e) { 
	} catch (IOException e) { 
		//忽略异常处理 
	} 
	return null; 
}
</pre>
<p>&nbsp;</p>
<p><strong>3.4.2 注册转换器</strong> <br>&nbsp;&nbsp;&nbsp; 使用premain函数注册字节码转换器，该方法在main函数之前执行。</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20class%20MyClassFileTransformer%20implements%20ClassFileTransformer%20%7B%20%0A%20%20%20%20public%20static%20void%20premain(String%20options%2C%20Instrumentation%20ins)%20%7B%20%0A%20%20%20%20%20%20%20%20%2F%2F%E6%B3%A8%E5%86%8C%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%AC%E6%8D%A2%E5%99%A8%20%0A%20%20%20%20%20%20%20%20ins.addTransformer(new%20MyClassFileTransformer())%3B%20%0A%7D%20%0A%7D%20%0A%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">class</span><span>&nbsp;MyClassFileTransformer&nbsp;</span><span class="keyword">implements</span><span>&nbsp;ClassFileTransformer&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;premain(String&nbsp;options,&nbsp;Instrumentation&nbsp;ins)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//注册我自己的字节码转换器&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ins.addTransformer(<span class="keyword">new</span><span>&nbsp;MyClassFileTransformer());&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="13" title="AOP的实现机制" style="display: none;">public class MyClassFileTransformer implements ClassFileTransformer { 
    public static void premain(String options, Instrumentation ins) { 
        //注册我自己的字节码转换器 
        ins.addTransformer(new MyClassFileTransformer()); 
} 
} 

</pre>
<p><strong></strong>&nbsp;</p>
<p><strong>3.4.3 配置和执行 <br></strong>&nbsp;&nbsp;&nbsp; 需要告诉JVM在启动main函数之前，需要先执行premain函数。首先需要将premain函数所在的类打成jar包。并修改该jar包里的META-INF\MANIFEST.MF 文件。&nbsp;</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=Manifest-Version%3A%201.0%20%0APremain-Class%3A%20bci.%20MyClassFileTransformer" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span>Manifest-Version:&nbsp;</span><span class="number">1.0</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>Premain-Class:&nbsp;bci.&nbsp;MyClassFileTransformer&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="14" title="AOP的实现机制" style="display: none;">Manifest-Version: 1.0 
Premain-Class: bci. MyClassFileTransformer</pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp; 然后在JVM的启动参数里加上。-javaagent:D:\java\projects\opencometProject\Aop\lib\aop.jar <br><strong></strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.4.4 输出 </strong></p>
<p><strong>&nbsp;&nbsp;&nbsp; </strong>执行main函数，你会发现切入的代码无侵入性的织入进去了。</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20static%20void%20main(String%5B%5D%20args)%20%7B%20%0A%20%20%20new%20Business().doSomeThing()%3B%20%0A%20%20%20new%20Business().doSomeThing2()%3B%20%0A%7D%20%0A%20" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">static</span><span>&nbsp;</span><span class="keyword">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;<span class="keyword">new</span><span>&nbsp;Business().doSomeThing();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;<span class="keyword">new</span><span>&nbsp;Business().doSomeThing2();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="15" title="AOP的实现机制" style="display: none;">public static void main(String[] args) { 
   new Business().doSomeThing(); 
   new Business().doSomeThing2(); 
} 
 </pre>
<p>&nbsp;&nbsp; 输出</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=model%2FBusiness%20%0Asun%2Fmisc%2FCleaner%20%0Ajava%2Flang%2FEnum%20%0Amodel%2FIBusiness%20%0Amodel%2FIBusiness2%20%0A%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%20%0A%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%20%0A%E6%89%A7%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%912%20%0Ajava%2Flang%2FShutdown%20%0Ajava%2Flang%2FShutdown%24Lock%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span>model/Business&nbsp;&nbsp;&nbsp;</span></span></li><li><span>sun/misc/Cleaner&nbsp;&nbsp;&nbsp;</span></li><li><span>java/lang/Enum&nbsp;&nbsp;&nbsp;</span></li><li><span>model/IBusiness&nbsp;&nbsp;&nbsp;</span></li><li><span>model/IBusiness2&nbsp;&nbsp;&nbsp;</span></li><li><span>记录日志&nbsp;&nbsp;&nbsp;</span></li><li><span>执行业务逻辑&nbsp;&nbsp;&nbsp;</span></li><li><span>执行业务逻辑<span class="number">2</span><span>&nbsp;&nbsp;&nbsp;</span></span></li><li><span>java/lang/Shutdown&nbsp;&nbsp;&nbsp;</span></li><li><span>java/lang/Shutdown$Lock&nbsp;&nbsp;&nbsp;</span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="16" title="AOP的实现机制" style="display: none;">model/Business 
sun/misc/Cleaner 
java/lang/Enum 
model/IBusiness 
model/IBusiness2 
记录日志 
执行业务逻辑 
执行业务逻辑2 
java/lang/Shutdown 
java/lang/Shutdown$Lock 
</pre>
<p>&nbsp;&nbsp;</p>
<p>&nbsp;从输出中可以看到系统类加载器加载的类也经过了这里。 </p>
<p>&nbsp;</p>
<p><strong>4 AOP实战</strong> <br>说了这么多理论，那AOP到底能做什么呢？ AOP能做的事情非常多。 </p>
<ul>
<li>性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。</li>
<li>缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。</li>
<li>软件破解，使用AOP修改软件的验证类的判断逻辑。</li>
<li>记录日志，在方法执行前后记录系统日志。</li>
<li>工作流系统，工作流系统需要将业务代码和流程引擎代码混合在一起执行，那么我们可以使用AOP将其分离，并动态挂接业务。</li>
<li>权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。&nbsp;<br><strong></strong>
</li>
</ul>
<p><strong>4.1 Spring的AOP <br></strong>&nbsp;&nbsp;&nbsp; Spring默认采取的动态代理机制实现AOP，当动态代理不可用时（代理类无接口）会使用CGlib机制。但Spring的AOP有一定的缺点，第一个只能对方法进行切入，不能对接口，字段，静态代码块进行切入（切入接口的某个方法，则该接口下所有实现类的该方法将被切入）。第二个同类中的互相调用方法将不会使用代理类。因为要使用代理类必须从Spring容器中获取Bean。第三个性能不是最好的，从3.3章节我们得知使用自定义类加载器，性能要优于动态代理和CGlib。 <br>可以获取代理类</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20IMsgFilterService%20getThis()%20%0A%7B%20%0A%20%20%20%20%20%20%20%20return%20(IMsgFilterService)%20AopContext.currentProxy()%3B%20%0A%7D%20%0A%0Apublic%20boolean%20evaluateMsg%20()%20%7B%20%0A%20%20%20%2F%2F%20%E6%89%A7%E8%A1%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E5%B0%86%E7%BB%87%E5%85%A5%E5%88%87%E5%85%A5%E9%80%BB%E8%BE%91%20%0Areturn%20getThis().evaluateMsg(String%20message)%3B%20%0A%7D%20%0A%0A%40MethodInvokeTimesMonitor(%22KEY_FILTER_NUM%22)%20%0Apublic%20boolean%20evaluateMsg(String%20message)%20%7B%20%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;IMsgFilterService&nbsp;getThis()&nbsp;&nbsp;&nbsp;</span></span></li><li><span>{&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span><span>&nbsp;(IMsgFilterService)&nbsp;AopContext.currentProxy();&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;evaluateMsg&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;执行此方法将织入切入逻辑&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">return</span><span>&nbsp;getThis().evaluateMsg(String&nbsp;message);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="annotation">@MethodInvokeTimesMonitor</span><span>(</span><span class="string">"KEY_FILTER_NUM"</span><span>)&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;evaluateMsg(String&nbsp;message)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="17" title="AOP的实现机制" style="display: none;">public IMsgFilterService getThis() 
{ 
        return (IMsgFilterService) AopContext.currentProxy(); 
} 

public boolean evaluateMsg () { 
   // 执行此方法将织入切入逻辑 
return getThis().evaluateMsg(String message); 
} 

@MethodInvokeTimesMonitor("KEY_FILTER_NUM") 
public boolean evaluateMsg(String message) { 
</pre>
<p>&nbsp;不能获取代理类</p>
<div class="dp-highlighter" id=""><div class="bar"><div class="tools">Java代码 <embed wmode="transparent" src="/javascripts/syntaxhighlighter/clipboard_new.swf" width="14" height="15" flashvars="clipboard=public%20boolean%20evaluateMsg%20()%20%7B%20%0A%20%20%20%2F%2F%20%E6%89%A7%E8%A1%8C%E6%AD%A4%E6%96%B9%E6%B3%95%E5%B0%86%E4%B8%8D%E4%BC%9A%E7%BB%87%E5%85%A5%E5%88%87%E5%85%A5%E9%80%BB%E8%BE%91%20%0Areturn%20evaluateMsg(String%20message)%3B%20%0A%7D%20%0A%0A%40MethodInvokeTimesMonitor(%22KEY_FILTER_NUM%22)%20%0Apublic%20boolean%20evaluateMsg(String%20message)%20%7B%20%0A%0A" quality="high" allowscriptaccess="always" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer">&nbsp;</div></div><ol start="1" class="dp-j"><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;evaluateMsg&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li><li><span>&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;执行此方法将不会织入切入逻辑&nbsp;</span><span>&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">return</span><span>&nbsp;evaluateMsg(String&nbsp;message);&nbsp;&nbsp;&nbsp;</span></span></li><li><span>}&nbsp;&nbsp;&nbsp;</span></li><li><span>&nbsp;&nbsp;</span></li><li><span><span class="annotation">@MethodInvokeTimesMonitor</span><span>(</span><span class="string">"KEY_FILTER_NUM"</span><span>)&nbsp;&nbsp;&nbsp;</span></span></li><li><span><span class="keyword">public</span><span>&nbsp;</span><span class="keyword">boolean</span><span>&nbsp;evaluateMsg(String&nbsp;message)&nbsp;{&nbsp;&nbsp;&nbsp;</span></span></li></ol></div><pre name="code" class="java" codeable_type="Post" codeable_id="2261600" source_url="http://www.iteye.com/topic/1116696#2261600" pre_index="18" title="AOP的实现机制" style="display: none;">public boolean evaluateMsg () { 
   // 执行此方法将不会织入切入逻辑 
return evaluateMsg(String message); 
} 

@MethodInvokeTimesMonitor("KEY_FILTER_NUM") 
public boolean evaluateMsg(String message) { 

</pre>
<p>&nbsp;</p>
<p><strong></strong>&nbsp;<strong>4.2 参考资料</strong> </p>
<ul>
<li>Java 动态代理机制分析及扩展</li>
<li>CGlib的官方网站</li>
<li>ASM官方网站</li>
<li>JbossAOP </li>
<li>Java5特性Instrumenttation实践 <br>
</li>
</ul>
<p>&nbsp;</p>
</div></body></html>